<div class="step-text">
<p>Java's <strong><a class="theory-lookup not-relevant" href="/learn/step/3572" rel="noopener noreferrer nofollow" target="_blank" title="In Java, method overriding is a mechanism that allows a subclass to provide a specific implementation of a method that is already provided by its superclass. | The name and parameter of the overriding method in the subclass must be exactly the same as the method in the superclass. However, the return type can be the same as the superclass method or a subtype of it, which is known as the covariant return type. Method overriding enables subclasses to modify the behavior inherited from their superclass, giving it their own unique flair, similar to adding a special twist to a classic recipe.">method overriding</a></strong> is a pivotal feature that allows subclasses to redefine behaviors inherited from their superclasses. Think of it as Java's way of letting classes add their own unique flair to inherited methods. It's like giving a classic recipe your own special twist. In this tutorial, we'll explore the essentials of <a class="theory-lookup not-relevant" href="/learn/step/3572" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an instance method is a method that belongs to each object created of a particular class. | It can access fields of the specific object of the class. For example, if we have a class with two instance methods: method1() and method2(), and two objects: object1 and object2, the output of these methods will be different for each object because they have different values for the fields. To use an instance method, you must first create an object.">instance method</a> overriding in Java, its rules, and the role of the <code class="language-java">@Override</code> annotation.</p>
<h5 id="overriding-instance-methods">Overriding instance methods</h5>
<p>Java provides an opportunity to <a class="theory-lookup not-relevant" href="/learn/step/3572" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a declaration is a statement that introduces a variable, method, or class into the program. | It specifies the type of the entity being declared, its name, and other relevant information such as access modifier, return type (for method), and initial value (for variable). For example, the declaration of a method may include its name, return type, access modifier, and parameter list. Declarations are essential for Java to understand the structure and behavior of the program. Incorrect declarations can lead to compilation errors. In the context of variables, a declaration specifies the type, name, and initial value of a variable. The type of a variable determines what possible operations can be performed on the variable and which value can be stored in it. Every variable has a name (also known as an identifier) to distinguish it from others. Before using a variable, it must be declared. The general form of a variable declaration is: `type identifier = value;`

It's important to note that a declaration is not the same as an assignment.">declare</a> a method in a subclass with the same name as a method in the superclass. This is known as <strong>method overriding</strong>. The benefit of overriding is that a subclass can give its own specific implementation of a superclass method.</p>
<p><strong><a class="theory-lookup not-relevant" href="/learn/step/3572" rel="noopener noreferrer nofollow" target="_blank" title="In Java, method overriding is a mechanism that allows a subclass to provide a specific implementation of a superclass method. | The name and parameter of the overriding method in the subclass must be exactly the same as the superclass method. However, the return type can be the same as the superclass method or a subtype of it. This is known as the covariant return type. The benefit of overriding is that a subclass can inherit the behavior of a superclass and then modify it as needed. Method overriding allows a subclass to inherit from a superclass whose behavior is close enough and then change this behavior in the subclass.">Overriding methods</a></strong> in subclasses allows a class to inherit from a superclass whose behavior is <strong>"close enough" </strong>and then to change this behavior as the subclass needs.</p>
<p>Instance methods can be overridden if they are inherited by the subclass. The overriding method must have the same name, parameters (number and type of parameters), and the <a class="theory-lookup not-relevant" href="/learn/step/3572" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a return type is the data type of the value returned by a method. | Methods can return various types of data, such as integers, strings, or objects, depending on their implementation. If a method does not return a value, its return type is specified as void. When a method is called, the returned value can be assigned to a variable, printed, or passed as an argument to another method. Java also supports covariant return types, which allow a subclass to narrow the return type of an overridden method to a subtype of the original return type.">return type</a> (or a subclass of the type) as the overridden method.</p>
<p><strong>Example. </strong>Here<strong> </strong>is an example of overriding.</p>
<pre><code class="language-java">class Mammal {

    public String sayHello() {
        return "ohlllalalalalalaoaoaoa";
    }
}

class Cat extends Mammal {

    @Override
    public String sayHello() {
        return "meow";
    }
}

class Human extends Mammal {

    @Override
    public String sayHello() {
        return "hello";
    }
}</code></pre>
<p>The hierarchy includes three classes: <code class="language-java">Mammal</code>, <code class="language-java">Cat</code> and <code class="language-java">Human</code>. The class <code class="language-java">Mammal</code> has the method <code class="language-java">sayHello</code>. Each subclass overrides this method. The <code class="language-java">@Override</code> annotation indicates that the method is overridden. This annotation is optional but helpful.</p>
<p>Let's create instances and invoke the method.</p>
<pre><code class="language-java">Mammal mammal = new Mammal();
System.out.println(mammal.sayHello()); // it prints "ohlllalalalalalaoaoaoa"

Cat cat = new Cat();
System.out.println(cat.sayHello()); // it prints "meow"

Human human = new Human();
System.out.println(human.sayHello()); // it prints "hello"</code></pre>
<p>As you can see, each subclass has its own implementation of the method <code class="language-java">sayHello</code>.</p>
<p></p>
<div class="alert alert-primary">You can invoke the base class method in the overridden method using the keyword <code class="language-java">super</code>.</div>
<h5 id="rules-for-overriding-methods">Rules for overriding methods</h5>
<p>There are several rules for methods of subclasses which should override methods of a superclass:</p>
<ul>
<li>the method must have the same name as in the superclass;</li>
<li>the arguments should be exactly the same as in the superclass method;</li>
<li>the return type should be the same type or a subtype of the return type declared in the method of the superclass;</li>
<li>the access level must be the same or more open than the overridden method's access level;</li>
<li>a private method cannot be overridden because it's not inherited by subclasses;</li>
<li>if the superclass and its subclass are in the same package, then package-private methods can be overridden;</li>
<li><a class="theory-lookup not-relevant" href="/learn/step/3572" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a static method is a method that is associated with a class rather than an instance of a class. | It can be accessed directly using the class name and does not require the creation of a class instance. A static method can only access static fields and other static methods within the same class, and cannot refer to the `this` keyword because there is no instance context. Static methods are often used as utility methods that provide common functionality for the entire project. They can be called from instance methods, but not the other way around.">static methods</a> cannot be overridden.</li>
</ul>
<p>To verify these rules, there is a special annotation <code class="language-java">@Override</code>. It allows you to know whether a method will be actually <strong>overridden</strong> or not. If for some reason, the compiler decides that the method cannot be overridden, it will generate an error. But, remember, the annotation is not required, it's only for convenience.</p>
<h5 id="forbidding-overriding">Forbidding overriding</h5>
<p>If you'd like to forbid overriding of a method, declare it with the keyword <code class="language-java">final</code>.</p>
<pre><code class="language-java">public final void method() {
    // do something
}</code></pre>
<p>Now, if you try to override this method in a subclass, a compile-time error will occur.</p>
<h5 id="overriding-and-overloading-methods-together">Overriding and overloading methods together</h5>
<p>Recall, that <strong><a class="theory-lookup not-relevant" href="/learn/step/3572" rel="noopener noreferrer nofollow" target="_blank" title="In Java, method overloading is a feature that allows you to create multiple methods with the same name but different parameter types or number of parameters. | When a method is called, the Java compiler determines which version of the method to run based on the type, number, and order of the arguments provided. This makes the code more concise, easier to understand, and handles various inputs. Method overloading enables you to change a method's signature, including the number of parameters or their types. For example, having methods with the same name but different parameter types or number of parameters is a valid case of overloading.">overloading</a></strong> is a feature that allows a class to have more than one method with the same name, if their arguments are different.</p>
<p>We can also override and overload an instance method in a subclass at the same time. Overloaded methods do not override superclass instance methods. They are new methods, unique to the subclass.</p>
<p>The following example demonstrates it.</p>
<pre><code class="language-java">class SuperClass {

    public void invokeInstanceMethod() {
        System.out.println("SuperClass: invokeInstanceMethod");
    }
}

class SubClass extends SuperClass {

    @Override
    public void invokeInstanceMethod() {
        System.out.println("SubClass: invokeInstanceMethod is overridden");
    }
    
    // @Override -- method doesn't override anything
    public void invokeInstanceMethod(String s) {
        System.out.println("SubClass: overloaded invokeInstanceMethod(String)");
    }
}</code></pre>
<p>The following code creates an instance and calls both methods:</p>
<pre><code class="language-java">SubClass clazz = new SubClass();

clazz.invokeInstanceMethod();    // SubClass: invokeInstanceMethod() is overridden
clazz.invokeInstanceMethod("s"); // SubClass: overloaded invokeInstanceMethod(String)</code></pre>
<p>Remember, overriding and overloading are different mechanisms but you can mix them together in one class hierarchy.</p>
<h5 id="hiding-static-methods">Hiding static methods</h5>
<p>Static methods cannot be overridden. If a subclass has a static method with the same <a class="theory-lookup not-relevant" href="/learn/step/3572" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a method signature is a unique identifier for a method that comprises the method's name and its argument type. | It specifies the number, type, and order of parameters that a method expects as input. For example, the signature of the sum method that takes two integer parameters named a and b indicates that the sum function accepts two integer inputs. Method signatures are used to distinguish between methods with the same name that take various kinds or quantities of parameters and may be overloaded as a result.">signature</a> (name and parameters) as a static method in the superclass then the method in the subclass hides the one in the superclass. It's completely different from method overriding.</p>
<p>Look at this <strong>example:</strong></p>
<pre><code class="language-java">class Main {
    public static void main(String[] args) {
        SuperClass.staticMethod();          // it prints "super"
        new SuperClass().staticMethod();    // it prints "super"
        SubClass.staticMethod();            // it prints "sub"
        new SubClass().staticMethod();      // it prints "sub"

        SuperClass ss = new SubClass();
        ss.staticMethod();                  // it prints "super", because static method belongs to a class, not to an instance
    }
}

class SuperClass {
    public static void staticMethod() {
        System.out.println("super");
    }
}

class SubClass extends SuperClass {
    public static void staticMethod() {
        System.out.println("sub");
    }
}</code></pre>
<p>You will get a <a class="theory-lookup not-relevant" href="/learn/step/3572" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a compile-time error is a type of error that prevents a Java program from being compiled due to issues such as syntax errors, incorrect keyword usage, missing symbols, improper source code file names, invocation of non-existing methods, and other issues. | These errors are different from run-time errors, which occur during the execution of a program. Compile-time errors are typically easier to identify and fix because they prevent the program from compiling, while run-time errors may not be discovered until the program is running.">compile-time error</a> if a subclass has a static method with the same signature as an instance method in the superclass or vice versa. But if the methods have the same name but different parameters there should be no problems.</p>
<pre><code class="language-java">class SuperClass {
    public void instanceMethod() {
        System.out.println("super");
    }
}

class SubClass extends SuperClass {
    // Static method instanceMethod() in SubClass cannot override instance method instanceMethod() in SuperClass
    public static void instanceMethod() {
        System.out.println("sub");
    }
}</code></pre>
<h5 id="conclusion">Conclusion</h5>
<p><strong>Method overriding</strong> allows a subclass to use a method with the same name as in the superclass but with its own implementation. The overridden method must have the same name, parameters, and return type as the method in the superclass. To indicate overriding, you should use the <code class="language-java">@Override</code> annotation. Keep in mind that methods marked as <strong>final</strong> or <strong>static</strong> cannot be overridden by subclasses.</p>
</div>